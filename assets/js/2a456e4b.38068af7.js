"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[5522],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>m});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),c=d(n),m=a,y=c["".concat(l,".").concat(m)]||c[m]||p[m]||i;return n?r.createElement(y,o(o({ref:t},u),{},{components:n})):r.createElement(y,o({ref:t},u))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<i;d++)o[d]=n[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}c.displayName="MDXCreateElement"},9659:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>i,contentTitle:()=>o,metadata:()=>s,toc:()=>l,default:()=>u});var r=n(7462),a=(n(7294),n(3905));const i={id:"xest-105",title:"XEST-105 Updating Artists",sidebar_label:"XEST-105 Updating Artists"},o=void 0,s={unversionedId:"training/xest-105",id:"training/xest-105",isDocsHomePage:!1,title:"XEST-105 Updating Artists",description:"Now it is getting a bit more tricky.",source:"@site/docs/training/xest-105.md",sourceDirName:"training",slug:"/training/xest-105",permalink:"/docs/training/xest-105",editUrl:"https://github.com/CyprusCodes/xest/tree/main/documentation/docs/docs/training/xest-105.md",tags:[],version:"current",frontMatter:{id:"xest-105",title:"XEST-105 Updating Artists",sidebar_label:"XEST-105 Updating Artists"},sidebar:"training",previous:{title:"XEST-104 CRUD For Artists Table",permalink:"/docs/training/xest-104"},next:{title:"XEST-106 First Test",permalink:"/docs/training/xest-106"}},l=[],d={toc:l};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Now it is getting a bit more tricky."),(0,a.kt)("p",null,"It is great that we can create and list Artist records using our API now. What if we wanted to update a record? Maybe there is a typo in the Artist name, or you want to change the genre of an artist record. That sounds like a job for the HTTP PUT or PATCH verbs. Both of these methods are typically used to edit or update a resource in slightly different ways: The PUT HTTP request method is typically used to signify a total replacement of a resource The data in the database would be totally replaced with the data sent in the request body The PATCH HTTP request method is typically used to signify a partial replacement of a resource The data in the database would be merged with the data sent in the request body."),(0,a.kt)("p",null,"So given an artist record:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://minio.cypruscodes.com/beckend-new-chapter/21.png",alt:"alt_text",title:"id123"})),(0,a.kt)("p",null,"If you sent the following request payload with a PUT request"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://minio.cypruscodes.com/beckend-new-chapter/22.png",alt:"alt_text",title:"jazz"})),(0,a.kt)("p",null,"then you would expect the artist record after the update to look like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://minio.cypruscodes.com/beckend-new-chapter/23.png",alt:"alt_text",title:"123jazz"})),(0,a.kt)("p",null,"Note that the name field has been removed, because it was not in the request body, and we have totally overwritten the stored data."),(0,a.kt)("p",null,"If the same request body was sent in fa PATCH request however, you would expect the artist record after the update to look like this:"),(0,a.kt)("p",null,(0,a.kt)("img",{parentName:"p",src:"https://minio.cypruscodes.com/beckend-new-chapter/24.png",alt:"alt_text",title:"123frankjazz"})),(0,a.kt)("p",null,"Here, only part of the data has been updated - the part that was sent in the request."),(0,a.kt)("p",null,"So now, lets create your route at routes.js file. (Do not forget to import the ",(0,a.kt)("strong",{parentName:"p"},"updaTeArtistById")," at the top of the file)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'router.patch("/artist/:artistId", updateArtistById);\n')),(0,a.kt)("p",null,"It\u2019s time to create ",(0,a.kt)("strong",{parentName:"p"},"updateArtistById"),";"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const modifyArtistById = require("~root/actions/artists/modifyArtistById");\nconst handleAPIError = require("~root/utils/handleAPIError");\n\nconst patchArtistById = async (req, res) => {\n const { artistId } = req.params;\n const { genre, name } = req.body;\n\n try {\n   const { artist } = await modifyArtistById({\n     artistId,\n     genre,\n     name\n   });\n\n   res.status(201).send({\n     artist\n   });\n } catch (err) {\n   handleAPIError(res, err);\n }\n};\n\nmodule.exports = patchArtistById;\n')),(0,a.kt)("p",null,"The id will be given as a parameter and the body that you want to change will be in the body."),(0,a.kt)("p",null,"In ",(0,a.kt)("inlineCode",{parentName:"p"},"app/actions/artists")," create your ",(0,a.kt)("inlineCode",{parentName:"p"},"modifyArtistById")," folder."),(0,a.kt)("p",null,"Create ",(0,a.kt)("inlineCode",{parentName:"p"},"index.js"),"file and queries folder under it. Index.js will be like below;"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const updateArtistById = require("./queries/updateArtistById");\n\nconst modifyArtistById = async ({ artistId, genre, name }) => {\n const artist = await updateArtistById({\n   artistId,\n   genre,\n   name\n });\n\n return { artist };\n};\n\nmodule.exports = modifyArtistById;\n')),(0,a.kt)("p",null,"Here comes the tricky part, the query file updateArtistById. You will give the initial, default value of null to genre and name. In case either of them or both of them are not null, the given value in the body will be changed."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, sql, sqlReduce } = require("~root/lib/database");\n\nconst updateArtistById = ({ artistId, genre = null, name = null }) => {\n const updates = [];\n\n if (genre !== null) {\n   updates.push(sql`genre = ${genre}`);\n }\n\n if (name !== null) {\n   updates.push(sql`name = ${name}`);\n }\n\n if (updates.length !== 0) {\n   return submitQuery`\n   UPDATE\n     Artists\n   SET\n     ${updates.reduce(sqlReduce)}\n   WHERE\n     artist_id = ${artistId};\n `;\n }\n return Promise.resolve();\n};\n\nmodule.exports = updateArtistById;\n')),(0,a.kt)("p",null,"Lets try it on postman! Feel free to change only name, then only genre and watch your change on your SQL workbench!"))}u.isMDXComponent=!0}}]);