"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[7260],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),d=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=d(n),h=a,m=p["".concat(l,".").concat(h)]||p[h]||c[h]||s;return n?r.createElement(m,i(i({ref:t},u),{},{components:n})):r.createElement(m,i({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:a,i[1]=o;for(var d=2;d<s;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},393:(e,t,n)=>{n.r(t),n.d(t,{frontMatter:()=>s,contentTitle:()=>i,metadata:()=>o,toc:()=>l,default:()=>u});var r=n(7462),a=(n(7294),n(3905));const s={id:"securing-api-endpoints",title:"Securing API Endpoints",sidebar_label:"Securing API Endpoints"},i=void 0,o={unversionedId:"securing-api-endpoints",id:"securing-api-endpoints",isDocsHomePage:!1,title:"Securing API Endpoints",description:"YUP Schema",source:"@site/docs/securing-api-endpoints.md",sourceDirName:".",slug:"/securing-api-endpoints",permalink:"/docs/securing-api-endpoints",editUrl:"https://github.com/CyprusCodes/xest/tree/main/documentation/docs/docs/securing-api-endpoints.md",tags:[],version:"current",frontMatter:{id:"securing-api-endpoints",title:"Securing API Endpoints",sidebar_label:"Securing API Endpoints"},sidebar:"docs",previous:{title:"Autherization",permalink:"/docs/authorization"},next:{title:"Digital Ocean",permalink:"/docs/digital-ocean"}},l=[{value:"YUP Schema",id:"yup-schema",children:[],level:2},{value:"Securing Access To Resources With Yup Async Validators",id:"securing-access-to-resources-with-yup-async-validators",children:[],level:2},{value:"Validating Request Payloads With Yup Schemas",id:"validating-request-payloads-with-yup-schemas",children:[],level:2},{value:"Validating The Existence of a Record With Yup Schemas",id:"validating-the-existence-of-a-record-with-yup-schemas",children:[],level:2}],d={toc:l};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"yup-schema"},"YUP Schema"),(0,a.kt)("p",null,"Xest has Javascript schema builder; ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/jquense/yup"},(0,a.kt)("strong",{parentName:"a"},"Yup"))," packed in and ready to be used for value parsing and validation. By convention the schema folder is suggested to be nested under the related controller function's folder as shown below;"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\u2500\u2500 deleteUserPayment\n\xa0\xa0 \u251c\u2500\u2500 index.js\n\xa0\xa0 \u2514\u2500\u2500 schemas\n\xa0\xa0     \u251c\u2500\u2500 deleteUserPaymentSchema.js\n\xa0\xa0     \u2514\u2500\u2500 queries\n\xa0\xa0         \u2514\u2500\u2500 selectUserPaymentById.js\n")),(0,a.kt)("h2",{id:"securing-access-to-resources-with-yup-async-validators"},"Securing Access To Resources With Yup Async Validators"),(0,a.kt)("p",null,"For an endpoint to be secure, non-authorized users should be forbidden to modify or delete data. So userNo#1 should not be allowed to modify or delete userNo#2\u2019s data.\nWith yup library\u2019s built-in \u2018test\u2019 method you can check if the userId requesting to modify/delete the resource belongs to the user with the same userId.\nYou will need a query function to fetch the unique id of the data in the database and the userId coming from the header. If the unique id of the data matches with the user's id coming from the header; the result of the validation function will be true and the request will be validated."),(0,a.kt)("p",null,"All tests must provide a name, an error message and a validation function that must return true when the current value is valid and false or a ValidationError otherwise."),(0,a.kt)("p",null,"Query to fetch the unique id of the data and the user id;"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, getFirst } = require("~root/lib/database");\n\nconst selectUserPaymentById = ({ userId, userPaymentId }) => submitQuery`\n    SELECT \n        user_payment_id\n    FROM user_payments\n    WHERE user_id = ${userId} AND user_payment_id = ${userPaymentId};\n`;\n\nmodule.exports = getFirst(selectUserPaymentById, "user_payment_id");\n')),(0,a.kt)("p",null,"Schema function;"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const yup = require("yup");\nconst selectUserPaymentById = require("./queries/selectUserPaymentById");\n\nconst deleteUserPaymentSchema = yup.object().shape({\n  userPaymentId: yup\n    .number()\n    .required()\n    .label("User Payment Id")\n    .test(\n      "doesUserPaymentBelongToUser",\n      "Invalid User Payment Id",\n      async function test(userPaymentId) {\n        const { userId } = this.parent;\n        return selectUserPaymentById({ userId, userPaymentId }).then(\n          (userPayment) => {\n            if (userPayment) {\n              return true;\n            }\n            return false;\n          }\n        );\n      }\n    ),\n});\nmodule.exports = deleteUserPaymentSchema;\n')),(0,a.kt)("h2",{id:"validating-request-payloads-with-yup-schemas"},"Validating Request Payloads With Yup Schemas"),(0,a.kt)("p",null,"With Yup Schema validation you can check if the information provided by a user is in the correct type of input.\nYou will be validating the data entered so instead of getting 500 API errors when the payload sent by the user is in the incorrect form you; will get a clear and constructive error message stating what the requirements of a field according to the database schema is. You will be creating schema with built in base methods and the bare minimum suggested is;"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"\u2018type\u2019 which can be ",(0,a.kt)("strong",{parentName:"li"},"string, number, object, array, boolean")," etc\u2026"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"\u2018label\u2019")," that will override the key name used in error messages."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"\u2018typeError\u2019")," that will be thrown for failed type checks.")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const yup = require("yup");\n\nconst putUserDetailsSchema = yup.object().shape({\n  firstName: yup\n    .string()\n    .min(1, "This field can not be empty!")\n    .max(50, "This field has to be be less than 50 characters")\n    .label("First Name")\n    .typeError("Not a valid name"),\n  lastName: yup\n    .string()\n    .min(1, "This field can not be empty!")\n    .max(50, "This field has to be be less than 50 characters")\n    .label("Last Name")\n    .typeError("Not a valid name"),\n  password: yup\n    .string()\n    .min(1, "This field can not be empty!")\n    .max(500, "This field has to be be less than 500 characters")\n    .label("Password")\n    .typeError("Not a valid password"),\n  details: yup\n    .object()\n    .label("User Details")\n    .typeError("Not valid user details"),\n  email: yup\n    .string()\n    .min(1, "This field can not be empty!")\n    .max(50, "This field should be less than 50 characters")\n    .email()\n    .label("Email")\n    .typeError("Not a valid email address"),\n});\n\nmodule.exports = putUserDetailsSchema;\n')),(0,a.kt)("p",null,"After creating the yup schema it's imported at the top level and used in the controller function within try and catch blocks of code.\nSince the first thing you need to do before editing the database is to validate the entries, you will need to write the schema as the first function in the try and catch blocks. If all types of data are in the correct form, the user will be allowed to modify the database."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"  try {\n    await patchUserDetailsSchema.validate(\n      {\n        firstName,\n        lastName,\n        password,\n        details,\n        email\n      },\n      {\n        abortEarly: false\n      }\n    );\n\n")),(0,a.kt)("h2",{id:"validating-the-existence-of-a-record-with-yup-schemas"},"Validating The Existence of a Record With Yup Schemas"),(0,a.kt)("p",null,"Another way of using Yup schema is when you want to insert a new record to your the database that needs to refer to another table's data. You should be validating the existence of the record so that it can be inserted into the new table in the database. This is done with 'test' method again, below is an example of the query fetching the record from the database and then the query is imported in the schema function to be used in 'test' method. So if the data exist and the result is true, the request is validated."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const { submitQuery, getFirst } = require("~root/lib/database");\n\nconst selectProviders = ({ providerId }) => submitQuery`\n  SELECT \n    provider_id\n  FROM providers\n  WHERE provider_id = ${providerId};\n  `;\n\nmodule.exports = getFirst(selectProviders, "provider_id");\n')),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},'const yup = require("yup");\nconst selectProviders = require("./queries/selectProviders");\n\nconst postUserProviderSchema = yup.object().shape({\n  metadata: yup\n    .object()\n    .label("User Provider Details")\n    .typeError("User provider details must be in JSON format"),\n  providerId: yup\n    .number()\n    .required()\n    .label("Provider Id")\n    .test(\n      "doesProviderExist",\n      "Invalid Provider Id",\n      async function test(providerId) {\n        return selectProviders({ providerId }).then((provider) => {\n          if (provider) {\n            return true;\n          }\n          return false;\n        });\n      }\n    ),\n});\nmodule.exports = postUserProviderSchema;\n')))}u.isMDXComponent=!0}}]);